---
title : "Why Kuberntes?"
description: "Reason for using k8s in MLOps"
lead: ""
draft: false
weight: 103
contributors: ["Jaeyeon Kim"]
menu:
  docs:
    parent: "introduction"
---

- TODO 적절한 이미지 중간에 추가하기

## MLOps 와 쿠버네티스

그렇다면 MLOps를 이야기할 때, 쿠버네티스라는 단어가 항상 함께 들리는 이유가 무엇일까요?

성공적인 MLOps 시스템을 구축하기 위해서는 앞서 말씀드린 여러 구성 요소들이 필요하지만, 각각의 구성요소들이 유기적으로 운영되기 위해서는 인프라 레벨에서 수많은 이슈들을 해결해야 합니다. 간단하게는 수많은 머신러닝 모델의 학습 요청을 순차적으로 실행 하는 것, 다른 작업 공간에서도 동일한 실행 환경을 보장해야 하는 것, 배포된 서비스에 장애가 생겼을 때 빠르게 대응해야 하는 것 등의 이슈 등을 생각해볼 수 있습니다. 여기서 컨테이너와 컨테이너 오케스트레이션 시스템의 필요성이 등장합니다.

머신러닝 모델을 개발하고 배포하는 과정에서, 다수의 개발자가 소수의 서버를 공유하면서 '1번 서버 사용 중이신가요?', 'GPU 사용 중이던 제 프로세스 누가 죽였나요?', '누가 서버에 x 패키지 업데이트 했나요?' 와 같은 상황에 고통받았던 경험이 한 번이라도 있으신 분들이라면 쿠버네티스를 비롯한 컨테이너 오케스트레이션 시스템 도입을 검토해보시는 것을 권장드립니다.

하나의 머신에서 파이썬 패키지의 격리와 관리를 위해 pyenv, virtualenv, conda 등의 파이썬 가상환경을 활용하는 것처럼, 애플리케이션 또는 프로세스의 격리와 관리를 위해서는 컨테이너 기반의 생태계를 활용하면 효과적으로 해결할 수 있습니다.

### 컨테이너와 도커

그렇다면 컨테이너란 무엇일까요? 마이크로소프트에서는 컨테이너를 다음과 같이 정의하고 있습니다.

> 컨테이너란 : 애플리케이션의 표준화된 이식 가능한 패키징

컴퓨터 공학에 익숙하신 분이라면 이미 잘 알고 계시겠지만, 머신러닝 연구에 익숙하신 분들이라면 이 문장만으로는 다소 어렵게 느껴질 수 있기에 간단한 비유를 들어보겠습니다.

여러분의 머신러닝 모델의 소스코드와 학습된 모델이 운영체제나 Python 실행 환경, 패키지 버전 등에 따라 다르게 동작하지 않도록, 소스코드와 함께 종속적인 실행 환경 전체를 **하나로 묶어서(패키징해서)** 공유하고 실행할 수 있는 기술이 바로 컨테이너라이제이션 기술입니다. 그리고 패키징된 형태를 컨테이너 이미지라고 부르며, 컨테이너 이미지를 공유함으로써 사용자는 어떤 시스템에서든 동일한 실행 결과를 보장할 수 있게 됩니다. 즉, 단순히 Jupyter Notebook 파일이나, 모델의 소스코드와 requirements.txt 파일을 공유하는 것이 아닌, 모든 실행 환경이 담긴 컨테이너 이미지를 공유한다면 *"제 노트북에서는 잘 되는데요?"* 와 같은 상황을 피할 수 있습니다.

컨테이너를 처음 접하시는 분들이 흔히 하시는 오해 중 하나는 "**컨테이너 == 도커**"라고 받아들이는 것입니다. 도커는 컨테이너와 동일한 의미를 지니는 개념이 아니라, 컨테이너를 띄우거나, 컨테이너 이미지를 만들고 공유하거나와 같이 컨테이너를 보다 쉽고 유연하게 사용할 수 있는 기능을 제공해주는 도구입니다. 즉, 컨테이너는 가상화 기술이고, 도커는 가상화 기술의 구현체라고 말할 수 있습니다.

다만, 도커는 여러 컨테이너 가상화 도구 중에서 쉬운 사용성과 높은 효율성을 바탕으로 가장 빠르게 성장하여 대세가 되었기에 컨테이너하면 도커라는 이미지가 자동으로 떠오르게 되었습니다. 이렇게 컨테이너와 도커 생태계가 대세가 되기까지는 다양한 이유가 있지만, 기술적으로 자세한 이야기는 **모두의 MLOps**의 범위를 넘어서기 때문에 다루지는 않겠습니다.

컨테이너 혹은 도커를 처음 들어보시는 분들에게는 **모두의 MLOps**의 내용이 다소 어렵게 느껴질 수 있기 때문에, [생활코딩](https://opentutorials.org/course/4781), [subicura 님의 개인 블로그 글](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html) 등의 자료를 먼저 참고해주시는 것을 권장합니다.

### 컨테이너 오케스트레이션 시스템과 쿠버네티스

그렇다면 컨테이너 오케스트레이션 시스템은 무엇일까요? **오케스트레이션**이라는 단어에서 추측해 볼 수 있듯이, 수많은 컨테이너들이 있을 때 컨테이너들이 서로 조화롭게 구동될 수 있도록 지휘하는 시스템에 비유할 수 있습니다.

관리해야 할 컨테이너의 수가 적다면 운영 담당자 한 명이서도 충분히 모든 상황에 대응할 수 있습니다. 하지만 24/7 정상 동작해야 하는 서비스가 컨테이너의 형태로 제공되고 있으며, 수 백 개 이상의 컨테이너가 수 십 대 이상의 서버에서 구동되고 있는 경우라면, 모든 서비스의 정상 동작 여부를 담당자 한 명이 파악하고 이슈에 대응하는 것은 불가능에 가깝습니다.

예를 들어, 모든 서비스가 정상적으로 동작하고 있는지 모니터링해야 하며, 특정 서비스가 정상 동작하고 있지 않다면 여러 컨테이너들의 로그를 모두 확인해가며 문제를 파악해야 하고, 특정 서버나 특정 컨테이너에 작업이 몰리지 않도록 스케줄링하고 로드 밸런싱하며, 필요한 경우에는 스케일링하는 등 수많은 작업을 담당해야 합니다.

이렇게 수많은 컨테이너들의 상태를 지속적으로 관리하고 운영하는 과정을 조금이나마 쉽게, 자동으로 할 수 있는 기능을 제공해주는 소프트웨어가 바로 컨테이너 오케스트레이션 시스템입니다. 머신러닝 관련된 상황을 예로 들면, GPU를 필요로 하는 딥러닝 학습 코드가 패키징된 컨테이너는 GPU 여유가 있는 서버에서 수행하고, 많은 메모리를 필요로 하는 데이터 전처리 코드가 패키징된 컨테이너는 Memory 여유가 많은 서버에서 수행하고, 학습 중에 서버에 문제가 생기면 자동으로 동일한 컨테이너를 다른 서버로 이동시키고 다시 학습을 진행하는 등의 작업을 사람이 일일히 수행하지 않고, 자동으로 관리하는 시스템을 개발한 뒤 맡기는 것입니다.

컨테이너 오케스트레이션 시스템 또한 여러 곳에서, 여러 이유로 그 필요성이 대두되면서 다양한 툴들이 등장하게 되었지만, 그 중 2021 년 현재를 기준으로 사실상의 표준은 쿠버네티스입니다.

CNCF 에서 2018 년 발표한 [Survey](https://www.cncf.io/blog/2018/08/29/cncf-survey-use-of-cloud-native-technologies-in-production-has-grown-over-200-percent/) 에 따르면 다음 그림과 같이 이미 두각을 나타내고 있었으며, 2019 년 발표한 [Survey](https://www.cncf.io/wp-content/uploads/2020/08/CNCF_Survey_Report.pdf)에서는 그 중 78 % 가 Production 레벨에서 사용하고 있는 것을 알 수 있습니다.
<img src="/images/docs/introduction/k8s-graph.png" title="k8s-graph"/>

쿠버네티스 생태계가 이처럼 커지게 된 이유에는 여러 가지 이유가 있습니다. 하지만 도커와 마찬가지로 쿠버네티스 역시 ML 기반의 서비스에서만 사용하는 기술이 아니기에, 자세히 다루기엔 상당히 많은 양의 기술적인 내용을 다루어야 할 것으로 생각하여 이번 **모두의 MLOps**에서는 자세한 내용은 생략할 예정입니다.

**모두의 MLOps**에서 앞으로 다룰 내용은 도커와 쿠버네티스에 대한 기반 지식이 어느 정도 갖춘 분들을 대상으로 작성하였습니다. 따라서 쿠버네티스에 대해 익숙하지 않으신 분들은 다음 [쿠버네티스 공식 문서](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/), [subicura 님의 개인 블로그 글](https://subicura.com/k8s/) 등의 쉽고 자세한 자료들을 먼저 참고해주시는 것을 권장합니다.
